\usepackage{luatexja}
\usepackage[hiragino-pron, nfssonly, deluxe, expert]{luatexja-preset}
\usepackage{pgfpages}
\usepackage{fontspec}
\usepackage{epigraph}
\usepackage{etoolbox}
\usepackage{tikz}
\usepackage{framed}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{libertine}
\usepackage{bxcoloremoji}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{diagbox}
\usepackage{caption}
\usepackage{xsavebox}

\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks,linkcolor=,urlcolor=links}

\usetheme{Boadilla}
\usecolortheme{seahorse}
% \usefonttheme{serif}

\setbeamercolor{page number in head/foot}{bg=blue!10}
\makeatother
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
    \begin{beamercolorbox}[wd=.4\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
      \usebeamerfont{author in head/foot}\insertshortauthor\hspace*{1ex}(\insertshortinstitute)
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
      \usebeamerfont{title in head/foot}\insertshorttitle
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,center]{date in head/foot}%
      \insertshortdate
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.1\paperwidth,ht=2.25ex,dp=1ex,center]{page number in head/foot}%
      \insertframenumber{} / \inserttotalframenumber\hspace*{1ex}
    \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatletter

\beamertemplatenavigationsymbolsempty

\setbeamertemplate{bibliography item}{\insertbiblabel}
\setbeamersize{description width=1cm}
\setbeamertemplate{items}[circle]
\setbeamertemplate{section in toc}[circle]
\setbeamertemplate{subsection in toc}{%
  \leavevmode\leftskip=2em
  {%
    \usebeamerfont*{itemize item}%
    \usebeamercolor{subsection number projected}%
    \color{bg}%
    \raise1.25pt\hbox{\donotcoloroutermaths$\bullet$}}%
  \hskip1.5ex\inserttocsubsection\par}
\setbeamercolor{title}{bg=white}
\setbeamertemplate{title page}
{%
  \vbox{}
  \vfill
  \begingroup
    \centering
    \hrulefill
    \vskip1em\par
    \begin{beamercolorbox}[sep=8pt,center,shadow=false,rounded=true]{title}
      \usebeamerfont{title}\inserttitle\par%
      \ifx\insertsubtitle\@empty%
      \else%
        \vskip0.25em%
        {\usebeamerfont{subtitle}\usebeamercolor[fg]{subtitle}\insertsubtitle\par}%
      \fi%     
    \end{beamercolorbox}%
    \hrulefill
    \vskip1em\par
    \begin{beamercolorbox}[sep=8pt,center,shadow=false,rounded=true]{author}
      \usebeamerfont{author}\insertauthor
    \end{beamercolorbox}
    \begin{beamercolorbox}[sep=8pt,center,shadow=false,rounded=true]{institute}
      \usebeamerfont{institute}\insertinstitute
    \end{beamercolorbox}
    \begin{beamercolorbox}[sep=8pt,center,shadow=false,rounded=true]{date}
      \usebeamerfont{date}\insertdate
    \end{beamercolorbox}\vskip0.5em
    {\usebeamercolor[fg]{titlegraphic}\inserttitlegraphic\par}
  \endgroup
  \vfill
}
\setbeamertemplate{blocks}[rounded][shadow=false]
\setbeamertemplate{note page}{\pagecolor{yellow!5}\insertnote}


% ============ ã“ã“ã‚’æ¶ˆã™ã¨Noteæ¶ˆãˆã‚‹ ================
\mode<handout>{%
  \setbeameroption{show notes on second screen=right}%
}
% ============ ã“ã“ã‚’æ¶ˆã™ã¨Noteæ¶ˆãˆã‚‹ ================


\renewcommand{\kanjifamilydefault}{\gtdefault}

\resetcounteronoverlays{lstlisting}
\definecolor{bluegray}{rgb}{0.4, 0.6, 0.8}
\DeclareCaptionFormat{listing}{{\color{bluegray}\lstlistingname}#2#3}
\captionsetup[lstlisting]{format=listing, font={footnotesize}}

\setmonofont[Ligatures=TeX]{CMU Typewriter Text}

\newcommand{\xcolon}{ï¼š}

\title[Generics in protocol/extension]{%
  {\bfseries\rmfamily\mcfamily\huge
    Generics in protocol/extension%
  }%
}
\author[Hikaru Yoshimura]{%
  Hikaru \textsc{Yoshimura}ï¼ˆå‰æ‘ å„ªï¼‰
}
\date[try! Swift Tokyo, March 21, 2019]{%
  \href{https://www.tryswift.co/events/2019/tokyo/en/}{try! Swift Tokyo on \oldstylenums{March 21, 2019}} \\
  {\scriptsize (\href{https://github.com/y-yu/try-swift-slide}{\texttt{y-yu/try-swift-slide@\GITAbrHash}})}%
}
\institute[Recruit Markting Partners Co., Ltd.]{%
  Recruit Markting Partners Co., Ltd.\\
  \href{mailto:yyu@mental.poker}{yyu@mental.poker}
}

\input{./lib/quotebox.tex}
\input{./lib/footnotemark.tex}
\input{./lib/ballon.tex}
\input{./lib/listings.tex}
\input{./lib/stack.tex}
\input{vc.tex}

\setbeamertemplate{items}[circle]

\newcommand\ballcircle[1]{%
  {%
    \usebeamercolor{enumerate item}%
    \tikzset{beameritem/.style={circle,inner sep=0,minimum size=2ex,text=enumerate item.bg,fill=enumerate item.fg,font=\footnotesize}}%
    \tikz[baseline=(n.base)]\node(n)[beameritem]{#1};%
  }
}
\newcommand\ballref[1]{%
  \ballcircle{\ref{#1}}
}

\newcommand\ce[1]{%
  \coloremoji{#1}
}

\newenvironment{notes}
  {%
    \begin{xlrbox}{NotesBox}
    \begin{minipage}{.95\textwidth}
    \small\rmfamily\mcfamily
    \begin{itemize}
    \setlength{\itemindent}{0em}
  }{%
    \end{itemize}
    \end{minipage}
    \end{xlrbox}
    \note{\theNotesBox}}

\makeatletter
\newsavebox\temp@simple@callout@box
\newcommand{\simplecallout}[3]{%
  \sbox{\temp@simple@callout@box}{\mbox{#3}}%
  \begin{center}%
    \begin{tikzpicture}%
      \calloutquote[width=1.1\wd\temp@simple@callout@box,position={(#1.5,-0.2)},fill=#2,rounded corners]{
        #3%
      }%
    \end{tikzpicture}%
  \end{center}
}
\makeatother
  
\begin{document}

\begin{frame}
  \vspace{5ex}
  \centering
  \maketitle
  
  \begin{notes}
    \item \textcolor{red}{ã“ã®å³å´ã®ãƒšãƒ¼ã‚¸ã¯ã‚³ãƒ¡ãƒ³ãƒˆãŒæ›¸ã„ã¦ã‚ã‚Šã¾ã™}
    ï¼ˆæœ€çµ‚çš„ã«ã¯æ¶ˆãˆã¾ã™ï¼‰

    \item ã‚¹ãƒ©ã‚¤ãƒ‰ãŒ16:9ã«ãªã‚Šã¾ã—ãŸï¼

    \item åŸºæœ¬çš„ã«ã‚¹ãƒ©ã‚¤ãƒ‰ã¯è‹±èªã§ã€ç™ºè¡¨ã¯æ—¥æœ¬èªã§ã™

    \item å³å´ã«è‹±èªã®ç”¨èªã®æ—¥æœ¬èªè¨³ã‚‚æ›¸ãã¾ã™

    \item ã¡ã‚‡ã£ã¨æ–‡å­—ãŒå¤šã™ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
    ãŸã ã‚¹ãƒ©ã‚¤ãƒ‰ã«ãªã„ã“ã¨ã‚’å–‹ã‚‹ã®ã¯å¤§å¤‰ã ã‘ã©ã€
    ã‚ã‚‹ã“ã¨ã‚’å½“æ—¥ã«é£›ã°ã™ã®ã¯ã¾ã å®¹æ˜“ãªã®ã§ã€
    ã¤ãã‚Œã‚‹ã ã‘ä½œã£ã¦ç·´ç¿’ã—ã¤ã¤ã©ã†ã«ã‹ã—ã‚ˆã†ã‹ãª

    \item Transcript:
    ã“ã®ãƒˆãƒ¼ã‚¯ã§ã¯ã€Œã©ã†ã‚„ã£ãŸã‚‰Genericsã‚’protocol/extensionã€ã§åˆ©ç”¨ã§ãã‚‹ã‹ï¼Ÿ
    ã«ã¤ã„ã¦HListã¨ã„ã†ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®çµåˆã‚’ä¾‹ã¨ã—ã¦è§£èª¬ã™ã‚‹ã€‚
    ã¾ãšã¯å•é¡Œã«ã¤ã„ã¦è©³ã—ãè¿°ã¹ã¦ã€ãã—ã¦Swiftã®protocol/extensionã«ã¤ã„ã¦
    Javaã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨æ¯”è¼ƒã—ãªãŒã‚‰è¿°ã¹ã¦ã„ãã€‚
    ãã—ã¦å®Ÿã¯protocol/extensionã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã®ã‚ˆã†ãªæ©Ÿèƒ½ãŒã‚ã‚‹ã“ã¨ã‚’
    åˆ©ç”¨ã—ã¦å•é¡Œã‚’ãªã‚“ã¨ã‹è§£æ±ºã™ã‚‹ã€‚
    æœ€å¾Œã«ç¾åœ¨ã®Swiftã§ã¯é›£ã—ã‹ã£ãŸã¨ã“ã‚ã«ã¤ã„ã¦è¿°ã¹ã¦
    å‚è€ƒæ–‡çŒ®ã‚’ç´¹ä»‹ã™ã‚‹ã€‚
  \end{notes}
\end{frame}

\begin{frame}
  \frametitle{Table of Contents}

  \tableofcontents

  \begin{notes}
    \item Transcript:
    ä»Šæ—¥ã®æµã‚Œ
  \end{notes}
\end{frame}

\section{Self-introduction}
\begin{frame}
  \frametitle{Self-introduction}
  
  \begin{columns}
    \begin{column}{0.3\textwidth}
      \begin{center}
        \begin{figure}
          \includegraphics[width=0.85\textwidth]{img/face.jpg}
        \end{figure}
      \end{center}
 
      \begin{table}[h]
        \begin{tabular}{ll}
          Twitter & \href{https://twitter.com/\_yyu\_}{@\_yyu\_} \\
          Qiita & \href{https://qiita.com/yyu}{yyu} \\
          GitHub & \href{https://github.com/y-yu}{y-yu} \\
        \end{tabular}
      \end{table}
    \end{column}
    \begin{column}{0.7\textwidth}
      \pause
      \begin{itemize}
        \item University of Tsukuba (Bachelor of CS)
        \begin{itemize}
          \item Programming Logic Group
        \end{itemize}
        
        \item Scala engineer at
        \href{http://www.recruit-mp.co.jp/}{Recruit Marketing Partners Co., Ltd.}

        \item I'm interested in
        \begin{itemize}
          \item Cryptography
          \item Functional Programming
          \item Quantum Information
          \item Typesetting (\LaTeX)
        \end{itemize}
      \end{itemize}
    \end{column}
  \end{columns}

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[Logic] è«–ç†
      \item[Scala] ã‚¹ã‚«ãƒ©
      \item[Cryptography] æš—å·
      \item[Functional Programming] é–¢æ•°ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°
      \item[Quantum Information] é‡å­æƒ…å ±
      \item[\LaTeX] ãƒ©ãƒ†ãƒƒã‚¯ãƒ»ãƒ©ãƒ†ãƒ•ï¼ˆæ¬§ç±³åœã§ã¯ãƒ©ãƒ†ãƒƒã‚¯ã‚‰ã—ã„ï¼‰
    \end{description}

    \item ã‚‚ã—ç™ºè¡¨ã§ã€Œé‡å­ã€ã¨è¨€ã£ãŸã‚‰ã€ãã‚Œã¯``quantum''ã§ãŠã­ãŒã„ã—ãŸã„ã§ã™ã€‚
    ãŸã¨ãˆã°ã€Œé‡å­ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã€ã¯``quantum computer''ã¨ã‹ã§ã™

    \item Transcript:
    ç­‘æ³¢å¤§å­¦ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ»ãƒ­ã‚¸ãƒƒã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã„ã†ç ”ç©¶å®¤ã«æ‰€å±ã—ã€
    å‹ã‚·ã‚¹ãƒ†ãƒ ã®ç ”ç©¶ã‚’è¡Œã£ãŸã€‚ãã—ã¦ç¾åœ¨ã¯ãƒªã‚¯ãƒ«ãƒ¼ãƒˆãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚ºã«ã¦
    Scalaã®ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã‚’ã—ã¦ã„ã‚‹ã€‚
    æ¥­å‹™ã§ã¯é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã—ã¦ã„ã‚‹ã€‚
    ã¾ãŸã€æš—å·ã‚„é‡å­ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«ã‚‚èˆˆå‘³ãŒã‚ã‚‹ã€‚
    ãã—ã¦ã“ã®ã‚¹ãƒ©ã‚¤ãƒ‰ã‚’ä½œã‚‹ãŸã‚ã«ã‚‚åˆ©ç”¨ã—ãŸ
    çµ„ç‰ˆã‚½ãƒ•ãƒˆ\LaTeX ã‚’ä½¿ã£ã¦æœ¬ã‚’ä½œæˆã™ã‚‹ã¨ã„ã£ãŸã“ã¨ã‚‚ã—ã¦ã„ã‚‹ã€‚
  \end{notes}
\end{frame}

\section{Problem}

\begin{frame}[fragile]
  \frametitle{Problem}

  \begin{itemize}
    \item First we are thinking about these data structures: \lstinline|Tuple| and \lstinline|List|
  \end{itemize}
  
  \begin{columns}
    \begin{column}{0.5\textwidth}
\begin{lstlisting}[style=swift]
struct Tuple<A, B> {
  let left: A
  let right: B
 
  init(_ l: A, _ r: B) {
    this.left = l
    this.right = r
  }
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
\begin{lstlisting}[style=swift]
enum List<A> {
  indirect case Cons(
    h: A,
    t: List<A>
  )
  case Nil
}
\end{lstlisting}
    \end{column}
  \end{columns}

  \pause
  \begin{itemize}
    \item<+-> \lstinline|Tuple| represents \emph{exact two} values
    for each type \lstinline|A| and \lstinline|B|

    \item<+-> And \lstinline|List| represents fixed type \lstinline|A| values
    whose number is \emph{more than or equal 0}
  \end{itemize}

  \uncover<+->{
    \simplecallout{-}{blue!20}{Can we make a List which have some type values?}
  }

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[data structure] ãƒ‡ãƒ¼ã‚¿é€ æ§‹
      \item[Tuple] ã‚¿ãƒ—ãƒ«ï¼ˆçµ„ï¼‰
      \item[List] ãƒªã‚¹ãƒˆ
      \item[type] å‹
      \item[Cons] ã‚³ãƒ³ã‚¹ï¼ˆå°‚é–€ç”¨èªï¼‰
      \item[Nil] ãƒ‹ãƒ«ï¼ˆå°‚é–€ç”¨èªï¼‰
    \end{description}

    \item Transcript:
    ã‚¿ãƒ—ãƒ«ã¯ã¡ã‚‡ã†ã©1ã¤ã¥ã¤Aã¨Bã®å‹ã‚’æŒã¤å€¤ã‚’è¡¨ã—ã€
    ãã—ã¦ãƒªã‚¹ãƒˆã¯1ã¤ã®å‹Aã‚’ã‚‚ã¤0å€‹ä»¥ä¸Šã®å€¤ã‚’è¡¨ã™ã€‚
    ãŸã ã€æˆ‘ã€…ã¯é•ã†å‹ã®å€¤ãŒä½•å€‹ã§ã‚‚ã¯ã„ã‚‹å‹ã‚’ã¤ãã‚Œãªã„ã ã‚ã†ã‹ï¼Ÿ
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Heterogeneous List}

  \begin{itemize}
    \item We are looking at \lstinline|HList| as follows
  \end{itemize}

\begin{lstlisting}[style=swift]
protocol HList {
  associatedtype Head
  associatedtype Tail: HList
}
\end{lstlisting}

  \pause
  \begin{itemize}
    \item<+-> \lstinline|HList| has two \lstinline|associatedtype|: \lstinline|Head| and \lstinline|Tail|
  \end{itemize}

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[HList] Hãƒªã‚¹ãƒˆï¼ˆHeterogeneous Listï¼‰
      \item[type member] å‹ãƒ¡ãƒ³ãƒãƒ¼
    \end{description}
 
    \item Headã¨Tailã‚‚å°‚é–€ç”¨èªã‹ã‚‚ï¼Ÿ

    \item Transcript:
    ã“ã“ã§ä»Šæ—¥ã¯``HList''ã¨ã„ã†ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ç´¹ä»‹ã™ã‚‹ã€‚
    HListã¯``Head''ã¨``Tail''ã¨ã„ã†2ã¤ã®å‹ãƒ¡ãƒ³ãƒãƒ¼ï¼ˆassociatedtypeï¼‰ã‚’
    æŒã¤ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Heterogeneous List}

  \begin{itemize}
    \item<+-> And there are two structs: \lstinline|HCons| and \lstinline|HNil|
  \end{itemize}

  \begin{columns}
    \begin{column}{0.45\textwidth}
\begin{lstlisting}[style=swift]
public enum Nothing { }    
struct HNil: HList {
  typealias Head = Nothing
  typealias Tail = HNil
   
  init() { }
   
  static var hNil = HNil()
}   
\end{lstlisting}
    \end{column}
    \begin{column}{0.55\textwidth}
\begin{lstlisting}[style=swift]
struct HCons<H, T: HList>: HList {
  typealias Head = H
  typealias Tail = T
  let head: Head
  let tail: Tail
   
  init(_ h: Head, _ t: Tail) {
    self.head = h
    self.tail = t
  }
}
\end{lstlisting}
    \end{column}
  \end{columns}

  \uncover<+->{
    \simplecallout{}{red!30}{Is it the same to \lstinline|List|?}
  }
  \uncover<+->{
    \simplecallout{-}{green!30}{No, it's not just \lstinline|List|}
  }

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[(H)Cons] (H)ã‚³ãƒ³ã‚¹
      \item[struct] æ§‹é€ ä½“
    \end{description}

    \item Consã¯ã€Œã‚³ãƒ³ã‚¹ã€ã¨ã„ã†ç”¨èªã§OK

    \item Transcript:
    ãã—ã¦ã€æ¬¡ã®ã‚ˆã†ãª2ã¤ã®æ§‹é€ ä½“ã§ã‚ã‚‹``HCons''ã¨``HNil''ãŒã‚ã‚Šã€
    ã“ã‚Œã‚‰ã¯ã“ã®å›³ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚
    ã“ã‚Œã¯ä¸€è¦‹ã™ã‚‹ã¨ãƒªã‚¹ãƒˆï¼ˆListï¼‰ã®ã‚ˆã†ã«è¦‹ãˆã‚‹ãŒã€å®Ÿã¯å˜ãªã‚‹ãƒªã‚¹ãƒˆã§ã¯ãªã„ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Heterogeneous List}

  \begin{itemize}
    \item<+-> \lstinline|HList| can have some values
    and their type order
  \end{itemize}

  \begin{columns}
    \begin{column}{0.3\textwidth}
      \begin{uncoverenv}<+->
\begin{lstlisting}[style=swift]
let a = HCons(
  1,
  HCons(
    true,
    HCons(
      "string",
      HNil.hnil() 
    )
  )
)
\end{lstlisting}
      \end{uncoverenv}
    \end{column}
    \begin{column}{0.7\textwidth}
      \begin{uncoverenv}<+->
\begin{lstlisting}[style=swift]
a: HCons<Int, HCons<Bool, HCons<String, HNil>>>
\end{lstlisting}
      \end{uncoverenv}
    \end{column}
  \end{columns}

  \begin{itemize}
    \item<+-> \lstinline|List| cannot have more than 1 type, but \lstinline|HList| have any of the number of types
  \end{itemize}

  \uncover<+->{
    \simplecallout{}{green!30}{Today, we'll consider the \lstinline|append| method of two \lstinline|HList|s}
  }

  \begin{notes}
    \item å‹ã¯ã¾ã‚ã„ã„ã‹ãªï¼Ÿï¼ˆNilãŒã¡ã‚‡ã£ã¨å¿ƒé…ï¼Ÿï¼‰

    \item ã“ã“ã§ãƒˆãƒ¼ã‚¯ã§ã¯HListã®appendã«ã¤ã„ã¦è€ƒãˆã‚‹ã¨å°å…¥ã™ã‚‹

    \item Transcript:
    HListã¯ã„ãã¤ã‹ã®å€¤ã¨ã€ãã®å€¤ã®å‹ã®é †åºã‚’æŒã¤ã“ã¨ãŒã§ãã‚‹ã€‚
    ãŸã¨ãˆã°ã€å·¦ã®å›³ã®ã‚ˆã†ã«Intã®1ã€Boolã®trueã€ãã—ã¦æ–‡å­—åˆ—ã®"string"ãŒä¸¦ã‚“ã ã‚ˆã†ãª
    ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚‚è¡¨ã‚ã™ã“ã¨ãŒã§ãã‚‹ã€‚
    ã“ã‚Œã¯Swiftã®ç¾åœ¨ã®å‡¦ç†ç³»ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ãŒã§ãã€
    å³å›³ã®ã‚ˆã†ãªå‹ãŒãã¡ã‚“ã¨ã¤ãã€‚
    Listã¯1ã¤ä»¥ä¸Šã®å‹ã‚’æŒã¤ã“ã¨ã¯ã§ããªã„ãŒã€
    ä¸€æ–¹ã§HListã¯ä½•ç¨®é¡ã§ã‚‚å‹ã‚’æŒã¤ã“ã¨ãŒã§ãã‚‹ã€‚
    ä»Šæ—¥ã¯ã€2ã¤ã®HListï¼ˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼‰ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ã€
    ãã‚Œã‚‰ã®appendï¼ˆçµåˆï¼‰ã‚’è€ƒãˆã¦ã„ããŸã„ã€‚
  \end{notes}
\end{frame}


\begin{frame}[fragile]
  \frametitle{\texttt{append} for \texttt{List}s}

  \begin{itemize}
    \item<+-> For now, in the case of the ordinary \lstinline|List|
  \end{itemize}

  \begin{uncoverenv}<+->
\begin{lstlisting}[style=swift]
func append<A>(_ a: List<A>, _ b: List<A>) -> List<A> {
  switch a {
  case let .Cons(h, t):
    return .Cons(h, append(t, b))
  case .Nil:
    return b
  }
}  
\end{lstlisting}     
  \end{uncoverenv}

  \begin{itemize}
    \item<+-> But, \lstinline|HList| may have more than 1 type,
    so it's not easy...\ce{ğŸ˜‡}
  \end{itemize}

  \uncover<+->{
    \simplecallout{-}{blue!20}{What should we use to implement it?}
  }

  \uncover<+->{
    \simplecallout{}{green!30}{It's difficult for Java
      but Swift has \lstinline|protocol| and \lstinline|extension|}
  }

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[protocol] ãƒ—ãƒ­ãƒˆã‚³ãƒ«
      \item[extension] ã‚¨ã‚¯ã‚¹ãƒ†ãƒ³ã‚·ãƒ§ãƒ³
    \end{description}
    
    \item appendã®ã“ã¨ã‚’ãƒˆãƒ¼ã‚¯ä¸­ã¯``concat(concatination)''ã®ã‚ˆã†ã«è¨€ã†ã‹ã‚‚

    \item Transcript:
    ã¾ãšã¯æ™®é€šã®Listã«ã¤ã„ã¦è€ƒãˆã‚‹ã€‚
    æ™®é€šã®Listã®çµåˆï¼ˆappendï¼‰ã¯ã“ã®ã‚ˆã†ã«å†å¸°çš„ï¼ˆrecursiveï¼‰ã«å®Ÿè£…ã§ãã‚‹ã€‚
    ã“ã®Listã®appendã¯1ã¤å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿Aã‚’ä½¿ã£ã¦ã„ã‚‹ãŒã€
    ã—ã‹ã—HListã¯ã„ãã¤ã‚‚å‹ãŒã‚ã‚‹ã€‚
    ã“ã†ã„ã†ã¨ãã©ã†ã‚„ã£ã¦å®Ÿè£…ã—ãŸã‚‰ã‚ˆã„ã ã‚ã†ã‹ï¼Ÿ
    Javaã§ã¯é›£ã—ã„ãŒã€Swiftã«ã¯``protocol/extension''ãŒã‚ã‚‹ã®ã§ã€
    ã“ã‚ŒãŒé”æˆã§ãã‚‹ã€‚
  \end{notes}
\end{frame}

\section{protocol/extension}

\begin{frame}[fragile]
  \frametitle{\texttt{protocol}/\texttt{extension}}

  \pause
  \begin{itemize}
    \item<+-> Swift \lstinline|protocol| sometimes could be said
    ``it's similler to \lstinline|interface| of Java''
  \end{itemize}

  \begin{uncoverenv}<+->
    \begin{columns}
      \begin{column}{0.55\textwidth}
\begin{lstlisting}[style=java, caption={Java interface}]
interface JsonWrite<A> {
  public JSON toJson(A a);
}
class User(???) implements JsonWrite<User> {
  public JSON toJson(User a) {
    ???
  }
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.45\textwidth}
\begin{lstlisting}[style=swift, caption={Swift protocol}]
protocol JsonWrite {
  associatedtype A
  func toJson(_ a: A) -> JSON
}
class User: JsonWrite {
  typealias A = User
  func toJson(_ a: A) -> JSON {
    ???
  }
}
\end{lstlisting}
      \end{column}
    \end{columns}
  \end{uncoverenv}

  \uncover<+->{
    \simplecallout{}{green!30}{It's not at all...}
  }

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[interface] ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
      \item[JSON] JSONï¼ˆã‚¸ã‚§ã‚¤ã‚½ãƒ³ï¼‰
      \item[Haskell] ãƒã‚¹ã‚±ãƒ«
    \end{description}

    \item Transcript:
    ã“ã“ã§SwiftãŒæŒã¤protocol/extensionã«ã¤ã„ã¦è€ƒãˆã‚‹ã€‚
    ã“ã‚Œã¯åƒ•ãŒSwiftã‚’å¥½ãã«æ€ã†ç†ç”±ã®1ã¤ã§ã€ã¨ã¦ã‚‚ãŠã‚‚ã—ã‚ã„æ©Ÿèƒ½ã§ã‚ã‚‹ã€‚
    Haskellã‚„Scalaã«ã‚‚ã€ã“ã®ã‚ˆã†ãªæ©Ÿèƒ½ãŒã‚ã‚‹ãŒJavaã«ã¯ãªã„ã¨æ€ã†ã€‚
    ãŸã ã€ã—ã°ã—ã°ã€ŒSwiftã®protocolã¯Javaã®interfaceã«ä¼¼ã¦ã„ã‚‹ã€ã¨
    è¨€ã‚ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚ãŸã—ã‹ã«æ¬¡ã®ã‚ˆã†ãªJSONã«å¤‰æ›ã§ãã‚‹ã‚ˆã†ãª
    protocolã§ã‚ã‚‹``JsonWrite''ã‚’è€ƒãˆã‚‹ã¨ã€ä»Š``User''ãŒ
    ``JsonWrite''ã‚’å®Ÿè£…ã™ã‚‹ï¼ˆimplementï¼‰ã€ã¾ãŸã¯é©åˆã™ã‚‹ï¼ˆconfirmï¼‰ã“ã¨ã‚’
    Javaã¨Swiftã§ãã‚Œãã‚ŒåŒã˜ã‚ˆã†ã«æ›¸ã‘ã‚‹ã€‚
    ã“ã‚Œã ã‘ã ã¨ç¢ºã‹ã«ä¼¼ã¦ã„ã‚‹ãŒã€ãŸã ãã‚Œã ã‘ã§ã¯ãªã„ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{protocol}/\texttt{extension}}

  \begin{itemize}
    \item<+-> If we need to extend a fixed data type such a \lstinline|Integer|

    \item<+-> However in Java, we cannot extend a fixed data type so
    we can't help but to use the \emph{Adapter pattern}
  \end{itemize}

  \begin{columns}
    \begin{column}{0.6\textwidth}
      \begin{uncoverenv}<.->
\begin{lstlisting}[style=java, caption={Adapter pattern in Java}]
class RichInteger implements JsonWrite<Integer> {
  public Integer n;
  public RichInteger(Integer i) {
    this.n = i
  }
  
  public JSON toJson(Integer a) {
    ???
  }
}
\end{lstlisting}
      \end{uncoverenv}
    \end{column}
    \begin{column}{0.4\textwidth}
      \begin{uncoverenv}<+->
\begin{lstlisting}[style=swift, caption={\texttt{extension} in Swift}]
extension Int: JsonWrite {
  typealias A = Int

  func toJson(_ a: Int) -> JSON {
    ???
  }
}    
\end{lstlisting}
      \end{uncoverenv}
    \end{column}
  \end{columns}

  \begin{itemize}
    \item<.-> But Swift has \lstinline|extension|,
    which find the function by the given types
  \end{itemize}

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[Adapter pattern] ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
    \end{description}

    \item Transcript:
    ã‚‚ã—ã€ã™ã§ã«å›ºã¾ã£ã¦ã—ã¾ã£ãŸIntegerã®ã‚ˆã†ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’JSONã«å¤‰æ›
    ã—ãŸããªã£ãŸã¨ãã€ã©ã†ã—ãŸã‚‰ã‚ˆã„ã ã‚ã†ã‹ã€‚
    ã“ã®ã‚ˆã†ãªå›ºå®šã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯ã€ãŸã¨ãˆã°ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®ã‚³ã‚¢ã‚„
    ã‚ã‚‹ã„ã¯ä»–äººã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ãªã©ã§å®šç¾©ã•ã‚ŒãŸå‹ã§ã‚ã£ã¦ã€
    æˆ‘ã€…ã®åŠªåŠ›ã§ä»Šã¤ãã£ãŸJsonWriteã‚’ä½¿ã£ã¦ã‚‚ã‚‰ã†ã®ã¯ä¸å¯èƒ½ã§ã‚ã‚‹ã€‚
    ã“ã†ã„ã†ã¨ãã€Javaã§ã¯Adapter patternã¨ã„ã†æ‰‹æ³•ã§æ¬¡ã®ã‚ˆã†ãª
    RichIntegerã®ã‚ˆã†ãªå‹ã‚’æ–°ãŸã«ã¤ãã£ã¦å¯¾å‡¦ã™ã‚‹ã“ã¨ãŒã—ã°ã—ã°ã‚ã‚‹ã€‚
    ã“ã‚Œã¯ã“ã‚Œã§å‹•ä½œã¯ã™ã‚‹ãŒã€ã—ã‹ã—æˆ‘ã€…ã®é–¢å¿ƒã¯Integerã‹ã‚‰
    RichIntegerã¸ç§»å‹•ã—ã¦ã—ã¾ã£ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Šãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è¤‡é›‘ã•ãŒä¸å¿…è¦ã«
    é«˜ã¾ã£ã¦ã—ã¾ã†ã€‚ä¸€æ–¹ã§Swiftã¯extensionã«ã‚ˆã‚Šã€ã“ã®å•é¡Œã‚’ã‚¹ãƒãƒ¼ãƒˆã«è§£æ±ºã§ãã‚‹ã€‚
    ã™ã§ã«ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã•ã‚ŒãŸå‹ã«å¯¾ã—ã¦ã€ã‚¢ãƒ‰ãƒ›ãƒƒã‚¯ã«æ©Ÿèƒ½ã‚’ä»˜ã‘åŠ ãˆã‚‹ã“ã¨ãŒå®¹æ˜“ã«ã§ãã‚‹ã€‚
    ã“ã‚Œã¯extensionãŒã€Œå‹ã‹ã‚‰æ©Ÿèƒ½ã‚’æ¢ã—ã¦ãã‚‹ã€ã¨ã„ã†èƒ½åŠ›ã‚’æŒã£ã¦ã„ã‚‹ã‹ã‚‰ã§ã‚ã‚‹ã€‚
  \end{notes}
\end{frame}


\begin{frame}[fragile]
  \frametitle{\texttt{protocol}/\texttt{extension}}
  
  \uncover<+->{
    \simplecallout{}{red!30}{What is the meaning of finding functions by the types?}
  }

  \begin{itemize}
    \item<+-> For example, let's think about \emph{overloading} like following
  \end{itemize}

  \begin{uncoverenv}<.->
    \begin{columns}
      \begin{column}{0.5\textwidth}
\begin{lstlisting}[style=swift]
1 + 1 // 2
\end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
\begin{lstlisting}[style=swift]
"hot" + "dog" // "hotdog"
\end{lstlisting}
      \end{column}
    \end{columns}
  \end{uncoverenv}

  \begin{itemize}
    \item<+-> Operator \lstinline|+| has two behaviors:
    \begin{itemize}
      \item \lstinline|(Int, Int) -> Int|
      \item \lstinline|(String, String) -> String|
    \end{itemize}

    \item<+-> So Swift looks up a suitable function by
    the arguments' types

    \item<+-> \lstinline|extension| is simillar like overloading
  \end{itemize}

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[overload] ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
      \item[operator] æ¼”ç®—å­
      \item[argument] å¼•æ•°
    \end{description}

    \item Transcript:
    ã€Œå‹ã‹ã‚‰æ©Ÿèƒ½ã‚’æ¢ã—ã¦ãã‚‹ã€ã¨ã¯ã©ã†ã„ã†ã“ã¨ã ã‚ã†ã‹ã€‚
    ã“ã‚Œã®ç°¡å˜ãªä¾‹ã¨ã—ã¦``overload''ãŒã‚ã‚‹ã€‚
    ãŠãªã˜``+''ã¨ã„ã†é–¢æ•°ã¾ãŸã¯æ¼”ç®—å­ã ãŒã€
    å¼•æ•°ã«ã‚ˆã£ã¦å·¦ã®ä¾‹ã§ã¯åŠ ç®—ã¨ãªã‚Šã€å³ã®ä¾‹ã§ã¯æ–‡å­—åˆ—ã®é€£çµï¼ˆconcatinationï¼‰ã¨ãªã‚‹ã€‚
    ã“ã‚Œã¯+ã«å¼•æ•°ã®å‹ã«å¿œã˜ã¦å°‘ãªãã¨ã‚‚2ã¤ã®æŒ¯ã‚‹èˆã„ãŒã‚ã‚Šã€
    ã‚‚ã—å¼•æ•°ã®å‹ãŒIntã¨Intãªã‚‰ã°è¶³ã—ç®—ã¨ã—ã¦Intã‚’è¿”ã—ã€
    ãã—ã¦ã‚‚ã—Stringã¨Stringãªã‚‰ã°æ–‡å­—åˆ—ã®é€£çµã¨ã—ã¦Stringã‚’è¿”ã™ã€‚
    ã¤ã¾ã‚Šã€SwiftãŒé©åˆ‡ãªæ©Ÿèƒ½ã‚’å¼•æ•°ã®å‹ã‹ã‚‰æ¢ã—ã¦ãã¦ãã‚Œã‚‹ã€‚
    extensionã¯ã“ã‚Œã«ä¼¼ãŸæŒ¯ã‚‹èˆã„ã‚’ã™ã‚‹ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{protocol}/\texttt{extension}}

  \begin{itemize}
    \item<+-> We can write \lstinline|+| function using
    \lstinline|protocol| and \lstinline|extension|
  \end{itemize}
  
  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
protocol Plusable {
  associatedtype A
  func +(_ a: A, _ b: A) -> A
}    
\end{lstlisting}

    \begin{columns}
      \begin{column}{0.5\textwidth}
\begin{lstlisting}[style=swift]
extension Int: Plusable {
  typealias A = Int
  func +(_ a: A, _ b: A) -> A {
    // `Int.plus` maybe not exist...
    return Int.plus(a, b)
  }
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
\begin{lstlisting}[style=swift]
extension String: Plusable {
  typealias A = String
  func +(_ a: A, _ b: A) -> A {
    return a.stringByAppendingString(b)
  }
}
\end{lstlisting}
      \end{column}
    \end{columns}
  \end{uncoverenv}

  \begin{itemize}
    \item<+-> Overloading can be done by \lstinline|protocol| and \lstinline|extension|
  \end{itemize}

  \begin{notes}
    \item Transcript:
    ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã®ã‚ˆã†ãªã“ã¨ãŒã§ãã‚‹ã¨ç¤ºã™ãŸã‚ã«ã€
    ã“ã®+ã‚’protocol/extensionã§æ›¸ã„ã¦ã¿ã‚‹ã€‚
    ``Plusable''ã¨ã„ã†protocolã‚’ã¤ãã‚Šã€ãã‚Œã®extensionã¨ã—ã¦
    Intã¨Stringã«ãã‚Œãã‚Œ+æ¼”ç®—å­ã‚’å®šç¾©ã™ã‚‹ã€‚
    ã“ã®ã‚ˆã†ã«ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ãŒã™ã‚‹ã“ã¨ã¯protocol/extensionã§
    åŒã˜ã‚ˆã†ã«è¡Œã†ã“ã¨ãŒã§ãã‚‹ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{protocol}/\texttt{extension}}

  \begin{itemize}
    \item<+-> \lstinline|extension| can use another
    \lstinline|extension| defined by a \lstinline|protocol|
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
extension Array: JsonWrite where Element: JsonWrite {
  typealias A = Array<Element>

  func toJson(_ a: Array<Element>): JSON {
    ???
  }
}
\end{lstlisting}
  \end{uncoverenv}

  \uncover<+->{
    \simplecallout{}{green!30}{%
      Can we make the \lstinline|append| for \lstinline|HList|s
      by \lstinline|extension|?}
  }

  \begin{notes}
    \item Transcript:
    ã•ã‚‰ã«extensionã¯ä»–ã®protocolã§å®šç¾©ã•ã‚ŒãŸextensionã‚’
    ä½¿ã†ã“ã¨ã‚‚ã§ãã‚‹ã€‚
    ãŸã¨ãˆã°ã“ã“ã§ã¯``Array''ã«ã•ãã»ã©ã®JsonWriteã‚’é©åˆã•ã›ã¦ã„ã‚‹ã€‚
    ãŸã ã—``where''å¥ã‚’ã¨ã‚‚ãªã£ã¦ã€Arrayã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿AãŒ
    JsonWriteã«é©åˆã—ã¦ã„ã‚‹ãªã‚‰ã°ã€Array<A>ã‚‚JsonWriteã«
    é©åˆã™ã‚‹ã¨ã„ã£ãŸã“ã¨ãŒæ›¸ã‘ã‚‹ã€‚
    ã“ã®extensionã‚’ä½¿ãˆã°HListã®appendã‚’ä½œã‚Œã‚‹ã®ã§ã¯ï¼Ÿ
  \end{notes}
\end{frame}

\section{Implementation}

\begin{frame}[fragile]
  \frametitle{Implementation}

  \begin{itemize}
    \item<+-> This is a \lstinline|append| for two normal \lstinline|List|s
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
func append<A>(_ a: List<A>, _ b: List<A>) -> List<A> {
  switch a {
  case let .Cons(h, t):
    return .Cons(h, append(t, b))
  case .Nil:
    return b
  }
}  
\end{lstlisting}     
  \end{uncoverenv}

  \begin{itemize}
    \item<+-> This \lstinline|append| has two cases depending on
    the first argument
    \begin{itemize}
      \item If it is \lstinline|Cons(h, t)|,
      then the \lstinline|append| calls itself
      passing \lstinline|t| as the first argument recursively
      
      \item If it is \lstinline|Nil|,
      then the function returns the second argument
    \end{itemize}

    \item<+-> This \lstinline|append| is using \emph{run time} dispatching,
    but we want to dispatch in \emph{compile time}
  \end{itemize}

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[recursively] å†å¸°çš„ã«
      \item[run time] ãƒ©ãƒ³ã‚¿ã‚¤ãƒ 
      \item[compile time] ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¿ã‚¤ãƒ 
    \end{description}

    \item Transcript:
    ã‚‚ã†ä¸€åº¦ã€æ™®é€šã®ãƒªã‚¹ãƒˆã®appendã‚’è¦‹ã¦ã¿ã‚‹ã¨ã€
    ã“ã‚Œã¯æœ€åˆã®å¼•æ•°ã«ã‚ˆã£ã¦2ã¤ã«å ´åˆåˆ†ã‘ã—ã¦ã„ã‚‹ã€‚
    ã‚‚ã—ãã‚ŒãŒCons(h, t)ãªã‚‰ã°ã€appendã‚’å†å¸°çš„ã«å‘¼ã³å‡ºã—
    ä¸€æ–¹ã§Nilãªã‚‰ã°ç¬¬äºŒå¼•æ•°ã‚’ãã®ã¾ã¾è¿”ã™ã€‚
    ã¤ã¾ã‚Šãƒªã‚¹ãƒˆã®é•·ã•ã«ã‚ˆã£ã¦æŒ™å‹•ã‚’å¤‰æ›´ã—ã¦ã„ã‚‹ãŒã€
    ãƒªã‚¹ãƒˆã®é•·ã•ã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®æƒ…å ±ã§ã‚ã‚‹ã€‚
    ãŸã ã€HListã¯å‹ãŒè¦ç´ ã®é †ç•ªã«ä¸¦ã‚“ã§ã„ã‚‹ã®ã§ã€
    å‹ã¨ã—ã¦é•·ã•ã‚’æŒã£ã¦ã„ã‚‹ã€‚å‹ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¿ã‚¤ãƒ ã®æƒ…å ±ãªã®ã§ã€
    ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¿ã‚¤ãƒ ã«æŒ™å‹•ã‚’å¤‰æ›´ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
    ã“ã“ã§extensionã‚’åˆ©ç”¨ã™ã‚‹ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Implementation}

  \begin{itemize}
    \item<+-> We are making a \lstinline|protocol| for the \lstinline|HList|s \lstinline|append| as follows
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
protocol HAppend {
  associatedtype Left: HList
  associatedtype Right: HList
  associatedtype Result: HList
   
  static func append(_ l1: Left, _ l2: Right) -> Result
}
\end{lstlisting}
  \end{uncoverenv}

  \begin{itemize}
    \item<+-> Then we'll think about its \lstinline|extension|
  \end{itemize}

  \begin{notes}
    \item Transcript:
    ã¨ã„ã†ã“ã¨ã§ã€ã¾ãšã¯``HAppend''ã¨ã„ã†HListã®appendã®protocolã‚’å®šç¾©ã™ã‚‹ã€‚
    ã“ã‚Œã¯Leftã¨Rightã¨ã„ã†2ã¤ã®HListã‚’å–ã‚Šã€ãã‚Œã‚’çµåˆã—ãŸçµæœã®
    Resultã¨ã„ã†HListã‚’è¿”ã™é–¢æ•°appendã‚’ã‚ã‚‰ã‚ã™protocolã§ã‚ã‚‹ã€‚
    ã“ã‚Œã®extensionãŒã©ã†ãªã‚‹ã‹ã‚’ä»Šå¾Œã¯è€ƒãˆã¦ã„ãã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Implementation}

  \begin{itemize}
    \item<+-> First we can create a pettern for that the
    first argument is \lstinline|HNil|
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
class App1<A: HList> {
  init() {}
}

extension App1: HAppend {
  typealias Left = HNil
  typealias Right = A
  typealias Result = A
   
  static func append(_ l1: HNil, _ l2: A) -> A {
    return l2
  }
}
\end{lstlisting}
  \end{uncoverenv}

  \begin{itemize}
    \item<+-> It just returns the second argument
  \end{itemize}

  \begin{notes}
    \item Transcript:
    ã¨ã„ã†ã“ã¨ã§ã€ã¾ãšã¯ç°¡å˜ãã†ãªHNilã®ã‚±ãƒ¼ã‚¹ã‹ã‚‰è€ƒãˆã‚ˆã†ã€‚
    HListç‰ˆappendã®æœ€åˆã®å¼•æ•°ã¯ã€associatedtype Leftã§
    ä¸ãˆã‚‰ã‚Œã‚‹ã®ã§ã€ãã‚ŒãŒHNilã§ã‚ã£ãŸå ´åˆã‚’è€ƒãˆã‚‹ã€‚
    ã“ã‚Œã¯å˜ã«ç¬¬äºŒå¼•æ•°ã®HListã‚’ãã®ã¾ã¾è¿”ã›ã°ã„ã„ãŒã€
    ãŸã ã“ã“ã§å•é¡Œã¨ãªã‚‹ã®ã¯ç¬¬äºŒå¼•æ•°ã‚’è¡¨ã™HListã®å‹ãŒæ‰‹å…ƒã«ãªã„ã€‚
    extensionãŒå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–ã‚ŒãŸã‚‰ã„ã„ãŒã€ãã‚Œã¯ã§ããªã„ã®ã§ã€
    é©å½“ãªå‹App1ã‚’ä½œã£ã¦å¯¾å‡¦ã™ã‚‹ã“ã¨ã«ã™ã‚‹ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Implementation}

  \begin{itemize}
    \item<+-> Next we have to make a \lstinline|HCons| pattern
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
extension App1: HAppend where A == HCons<?, ?> {
  ??? // There is non-working......
}
\end{lstlisting}
  \end{uncoverenv}

  \begin{itemize}
    \item<+-> How do we get the \lstinline|?| types?
    so it doesn't work well...\ce{ğŸ˜‡}

    \item<+-> There are two problems
    \begin{enumerate}
      \item A structure (\lstinline|class|, \lstinline|struct| and \lstinline|protcol|)
      can be conformed by the same \lstinline|protocol| \emph{at most one}

      \item And how do we get the \lstinline|append| function
      that can concat previous \lstinline|HList|s?
    \end{enumerate}
  \end{itemize}
  
  \begin{notes}
    \item Transcript:
    ã¨ã“ã‚ãŒæ¬¡ã«HConsã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è€ƒãˆã‚‹ã¨ã‚€ã¤ã‹ã—ããªã‚‹ã€‚
    ã¾ãšã€App1ã¯ã•ãã»ã©HNilã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§HAppendã«é©åˆã•ã›ã¦ã—ã¾ã£ãŸã€‚
    ã—ãŸãŒã£ã¦ã‚‚ã†ä¸€åº¦HAppendã«é©åˆã•ã›ã‚‹ã“ã¨ã¯SwiftãŒè¨±ã—ã¦ãã‚Œãªã„ã€‚
    ã¾ãŸã€HCons(h, t)ã®ã‚ˆã†ã«åˆ†è§£ã—ãŸã¨ã—ã¦ã€
    ã§ã¯ã“ã®tã‚’ä½¿ã£ãŸappendã‚’ã©ã“ã‹ã‚‰æŒã£ã¦ãã‚Œã°ã‚ˆã„ã ã‚ã†ã‹ã€‚
    æ™®é€šã®Listã®appendã§ã¯å‹ãŒåŒã˜ã ã£ãŸã®ã§ã‚ˆã‹ã£ãŸãŒã€
    ä¸€æ–¹ã§HListã§ã¯ãã†ã¯ã„ã‹ãªã„ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Solution for the former}

  \begin{itemize}
    \item<+-> We make an adapter class \lstinline|App3| following below
  \end{itemize}

  \begin{uncoverenv}<.->
    \begin{columns}
      \begin{column}{0.43\textwidth}
\begin{lstlisting}[style=swift]
class App3<A: HList, B: HList, C> {
  init() {}
}
\end{lstlisting}
      \end{column}
      \begin{column}{0.57\textwidth}
\begin{lstlisting}[style=swift]
extension App3: HAppend where A == HCons<C, B> {
  ???
}   
\end{lstlisting}
      \end{column}
    \end{columns}
  \end{uncoverenv}

  \begin{itemize}
    \item<.-> We can use \lstinline|App3| for \lstinline|HCons| case instead of \lstinline|App1|
    
    \item<+-> Then we have to decide the \lstinline|associatedtype|s
    of \lstinline|HAppend|
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
extension App3: HAppend where A == HCons<C, B> {
  typealias Left = A
  typealias Right = ? // What should we put?
  typealias Result = ? // What should we put?
}
\end{lstlisting}
  \end{uncoverenv}

  \uncover<+->{
    \simplecallout{}{red!30}{What should we put into types:
      \lstinline|Right| and \lstinline|Result|?}
  }
  
  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[App] ã‚¢ãƒƒãƒ—ï¼ˆApplyã®å…ˆé ­3æ–‡å­—ï¼‰
    \end{description}

    \item Transcript:
    ã‹ãªã‚Šå¼·å¼•ã ãŒã€3ã¤å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã—ã¾ãˆã°ã€
    HAppendã®associatedtypeã§ã‚ã‚‹Leftã€Rightã€Resultã«
    å¯¾å¿œã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã‹ã¤App3ã¯ã¾ã HAppendãŒé©åˆã—ã¦ã„ãªã„ã®ã§ã€
    HNilã®ã‚±ãƒ¼ã‚¹ã§ã‚ã‚‹App1ã¨è¡çªã™ã‚‹ã“ã¨ãŒãªã„ã€‚
    ã“ã‚Œã§ã¨ã‚Šã‚ãˆãšæœ€åˆã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ã€‚
    ãŸã ã€ãã†ã—ãŸã¨ãã«HAppendãŒæŒã¤å‹Leftã¨Rightã«ã©ã†ã„ã£ãŸ
    å‹ã‚’å…¥ã‚Œã‚Œã°ã‚ˆã„ã ã‚ã†ã‹ï¼Ÿ
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Solution for the latter}

  \begin{itemize}
    \item<+-> We add a type parameter called \lstinline|EV|
    to get the previous \lstinline|append|

    \item<+-> For this, we add 2 type parameters then
    the adapter class takes 5 parameters rather than 3
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
class App5<A: HList, B: HList, C: HList, D, EV: HAppend> {
  init() {}
}
\end{lstlisting}
  \end{uncoverenv}

  \begin{itemize}
    \item<+-> Finally we can substitute the types for \lstinline|associatedtype|s
    declared by \lstinline|HAppend|
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
extension App5: HAppend where A == EV.Left, B == EV.Right, C == EV.Result {
  typealias Left = HCons<D, A>
  typealias Right = X.B
  typealias Result = HCons<D, C>
}
\end{lstlisting}
  \end{uncoverenv}

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[EV] ã‚¨ãƒ“ãƒ‡ãƒ³ã‚¹ï¼ˆevidenceã€è¨¼æ‹ ï¼‰
    \end{description}

    \item Transcript:
    ãŸã ã€ãã‚Œã ã‘ã§ã¯1ã¤å‰ã®appendã€ã¤ã¾ã‚Šã¯
    ã€Œ1ã¤å°ã•ã„HListç”¨ã®appendã‚’æ¢ã—ã¦ãã‚‹ã€ã“ã¨ãŒã§ããªã„ã€‚
    Swiftã¯å‹ã‹ã‚‰æ©Ÿèƒ½ã‚’æ¢ã—ã¦ãã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã€å‹ã«æ©Ÿèƒ½ã‚’å‰²ã‚Šå½“ã¦ã‚Œã°ã„ã„ã€‚
    å¹¸ã„ãªã“ã¨ã«HListã®appendã¯å‹ã‹ã‚‰æ©Ÿèƒ½ãŒå”¯ä¸€ã«æ±ºå®šã§ãã‚‹ã€‚
    ç¾åœ¨ã¾ã•ã«å®šç¾©ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹HAppendã®LeftãŒHCons<H, T>ã ã¨ã—ãŸã‚‰ã€
    1ã¤å‰ã®HAppendã¯LeftãŒTã§ã‚ã‚‹ã€‚
    ã“ã®ã‚ˆã†ãªappendã‚’æ¢ã™ãŸã‚ã«ã€HListã§ã‚ã‚‹A, B, Cã‚’å–ã‚Šã€EVã¨ã„ã†å‹ã¯
    HListã§ã‚ã‚‹Aã¨HListã§ã‚ã‚‹Bã‚’å—ã‘å–ã£ã¦çµåˆã—ã€ãã—ã¦HList Cã‚’è¿”ã™æ©Ÿèƒ½ã‚’æŒã¤ã¨ã™ã‚‹ã€‚
    ãã†ã™ã‚Œã°ä»»æ„ã®å‹Dã«ã¤ã„ã¦ã€HCons<D, A>ã¨Bã‚’å—ã‘å–ã£ã¦HCons<D, C>ã‚’è¿”ã™
    appendã‚’ä½œã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã“ã†ã—ã¦Listã®appendã‚ˆã†ãªãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®å†å¸°ã‚’
    HListã®å‹ãƒ¬ãƒ™ãƒ«ã®å†å¸°ã«æŒã¡è¾¼ã‚€ã“ã¨ãŒã§ãã‚‹ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Solution for the latter}

\begin{lstlisting}[style=swift]
extension App5: HAppend where A == EV.Left, B == EV.Right, C == EV.Result {
  typealias Left = HCons<D, A>
  typealias Right = X.B
  typealias Result = HCons<D, C>
}
\end{lstlisting}

  \begin{itemize}
    \item It can be figured out by the picture
  \end{itemize}

  \pause
  \[
    \text{A} := \STwo{?_1, ?_2},\; \text{B} := \STwo{?_3, ?_4},\; \text{C} := \text{A} + \text{B} = \SFour{?_1, ?_2, ?_3, ?_4}
  \]

  \pause
  \begin{align*}
    \text{Left}\; &:= HCons(\mathbf{D}, A) = \SThree{\mathbf{D}, ?_1, ?_2} \\
    \text{Right}\; &:= \text{B} = \STwo{?_3, ?_4} \\
    \text{Result}\; &:= HCons(\mathbf{D}, \text{A}) + \text{B} = \SFive{\mathbf{D}, ?_1, ?_2, ?_3, ?_4} = HCons(D, C)
  \end{align*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Complete implementation}

  \begin{itemize}
    \item<+-> We get the perfect implementation for \lstinline|HList|s \lstinline|append| function
  \end{itemize}

  \begin{uncoverenv}<.->
\begin{lstlisting}[style=swift]
extension App1: HAppend {
  typealias Left = HNil
  typealias Right = A
  typealias Result = A
   
  static func append(_ l1: HNil, _ l2: A) -> A {
    return l2
  }
}
extension App5: HAppend where EV.Left == A, B == EV.Right, C == EV.Result {
  typealias Left = HCons<D, A>
  typealias Right = B
  typealias Result = HCons<D, C>
   
  static func append(_ l1: HCons<D, A>, _ l2: B) -> HCons<D, C> {
    return HCons(l1.head, EV.append(l1.tail, l2))
  }
}
\end{lstlisting}
  \end{uncoverenv}

  \begin{notes}
    \item Transcript:
    ã‚ˆã†ã‚„ãã§ãã‚ãŒã£ãŸã€‚
    ã“ã‚ŒãŒå®Ÿç”¨çš„ã‹ã©ã†ã‹ã¯æ­£ç›´ãªã¨ã“ã‚ã‚ã‹ã‚‰ãªããªã‚Šã¤ã¤ã‚ã‚‹ã€‚
    ãªãœãã†æ€ã†ã®ã‹ã‚’èª¬æ˜ã™ã‚‹ãŸã‚ã«ã€ã§ãã‚ãŒã£ãŸappendã®
    åˆ©ç”¨ä¾‹ã‚’è¦‹ã¦ã„ã“ã†ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example}

\begin{lstlisting}[style=swift]
let a = HCons(1, HCons("string", HNil.hNil))
let b = HCons(true, HCons(1.001, HNil.hNil))

typealias AA = HCons<String, HNil>
typealias A = HCons<Int, AA>
typealias BB = HCons<Double, HNil>
typealias B = HCons<Bool, BB>
typealias CC = HCons<String, B>
typealias C = HCons<Int, CC>
typealias AppC = App1<B>
typealias AppB = App5<HNil, B, B, String, AppC>
typealias AppA = App5<AA, B, CC, Int, AppB>

let appended = AppA.append(a, b)
\end{lstlisting}

  \uncover<.->{
    \simplecallout{-}{green!30}{This is it! \ce{ğŸ˜‡}}
  }

  \begin{notes}
    \item Transcript:
    ã“ã®ã‚ˆã†ã«EVã‚’æ‰‹ã§ä¸ãˆãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã€
    ã¡ã‚‡ã£ã¨å®Ÿç”¨ã§ä½¿ãˆã‚‹ã‚‚ã®ã«ã¯ãªã‚‰ãªã„â€¦â€¦ã€‚
  \end{notes}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example}

  \begin{itemize}
    \item<+-> We have to give Swift what the type \lstinline|EV| is
    because Swift doesn't infer it
  \end{itemize}

  \begin{notes}
    \item ç”¨èª
    \begin{description}
      \item[type inference] å‹æ¨è«–ï¼ˆã“ã®æ—¥æœ¬èªã‚’è¨€ã†å¯èƒ½æ€§ãŒé«˜ã„ï¼‰
    \end{description}
    
    \item Transcript:
    ã„ã‚ã„ã‚ãªæ–¹æ³•ã‚’è©¦ã—ã¦ã€ãªã‚“ã¨ã‹EVã‚’è‡ªå‹•ã§å¾—ã‚‹ã“ã¨ã¯ã§ããªã„ã ã‚ã†ã‹ï¼Ÿ
    ã¨ã„ã†ã“ã¨ã‚’è€ƒãˆã¦ã„ãŸã‚‚ã®ã®ã€ã©ã‚Œã‚‚ä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã€‚
    ãŸã¶ã‚“EVã¯æ‰‹å‹•ã§å…¥ã‚Œã‚‹ã—ã‹ãªã„ã ã‚ã†ã€‚
  \end{notes}
\end{frame}

\section{Conclusion}

\begin{frame}[fragile]
  \frametitle{Conclusion}

  \pause
  \begin{itemize}
    \item<+-> There are some interesting data types like \lstinline|HList|

    \item<+-> \lstinline|append| method is able to make by
    \lstinline|protocol| and \lstinline|extension|

    \item<+-> Swift's type inference is wanted by people to
    improve itself
    \begin{itemize}
      \item \lstinline|HList|s are very useful
      but we'll not use their \lstinline|append| in the production
    \end{itemize}
  \end{itemize}

  \begin{notes}
    \item Transcript:
    ã“ã®ãƒˆãƒ¼ã‚¯ã§ã¯HListã«ã¤ã„ã¦ç´¹ä»‹ã—ã€ãã—ã¦ãã‚Œã‚‰ã®
    appendã‚’å®Ÿè£…ã—ã¦ã„ã£ãŸã€‚
    ã•ã¦ã€ã‚‚ã—åƒ•ã®ãƒˆãƒ¼ã‚¯ã®ã‚¢ãƒ–ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã‚’èª­ã‚“ã§ã„ã‚‹äººãŒã„ãŸã‚‰
    ã€Œã©ã“ã«ã‚«ãƒªãƒ¼ãƒãƒ¯ãƒ¼ãƒ‰å¯¾å¿œãŒã§ã¦ããŸï¼Ÿã€ã¨æ€ã†ã‹ã‚‚ã—ã‚Œãªã„ã€‚
    å®Ÿã¯ãã†ã„ã†æ–¹æ³•ã‚’ã‚„ã£ã¦ã¿ãŸã‚‚ã®ã®ã€
    ç´¹ä»‹ã—ãŸApp1ã‚„App5ã‚’åˆ©ç”¨ã—ãŸãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã—ã‹ã€
    Swiftã®protocol/extensionã«ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’æŒã¡è¾¼ã‚€ã“ã¨ãŒã§ããªã‹ã£ãŸã€‚
    ä»Šå›ã€æŒ«æŠ˜ã—ãŸæ–¹æ³•ã‚‚ä»Šå¾Œã•ã‚‰ã«è€ƒãˆã¦ã„ããŸã„ã¨ã¯æ€ã†ã€‚
    ã¾ãŸã€Swiftã®å‹æ¨è«–ãŒã‚ˆã‚Šã‚ˆããªã‚Œã°ã€ã‚‚ã£ã¨ã‚ˆã„ã‚³ãƒ¼ãƒ‰ãŒæ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚‹ã¨æ€ã†ã€‚
  \end{notes}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \bibliographystyle{junsrt_url}
  \nocite{*}
  \bibliography{ref}

  \begin{notes}
    \item Transcript:
    ä»Šå›ã®ãƒˆãƒ¼ã‚¯ã§ã‚‚ã—å‹ã‚·ã‚¹ãƒ†ãƒ ã«èˆˆå‘³ã‚’æŒãŸã‚ŒãŸæ–¹ã¯ã€
    ãƒ”ã‚¢ãƒ¼ã‚¹ã•ã‚“ã®ã“ã®æœ¬ï¼ˆä¸ŠãŒåŸè‘—ã€ä¸‹ã¯æ—¥æœ¬èªè¨³ï¼‰ã‚’ãŠã™ã™ã‚ã—ãŸã„ã€‚
    å‹ã‚·ã‚¹ãƒ†ãƒ ã®åŸºç¤ã‹ã‚‰æœ¬æ ¼çš„ãªã¨ã“ã‚ã¾ã§è©³ç´°ã«è¨˜è¿°ã—ã¦ã‚ã‚‹ã€‚
    å½¢å¼çš„ãªã¨ã“ã‚ã¯ã©ã†ã—ã¦ã‚‚ã€Œå®šç¾©ãƒ»å®šç†ãƒ»è¨¼æ˜ã€ã¿ãŸã„ãªæµã‚Œã§
    ã¡ã‚‡ã£ã¨å›°æƒ‘ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€å®Ÿã¯ãã“ã¾ã§ã™ã”ã
    æœ€åˆã®ãƒãƒ¼ãƒ‰ãƒ«ãŒé«˜ã„ã‚ã‘ã§ã¯ãªã„ã¨æ€ã†ã€‚
    ã‚‚ã—èˆˆå‘³ãŒã‚ã‚‹ãªã‚‰è²·ã£ã¦ã¿ã¦ã»ã—ã„ã€‚
  \end{notes}
\end{frame}

\begin{frame}
  \centering
  {\Huge Thank you for your attention!}

  \begin{notes}
    \item Transcript:
    ã”é™è´ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚
  \end{notes}
\end{frame}

\end{document}
